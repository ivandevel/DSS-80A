//----------------------------------------------------------------------------

//DSS-90/DFS-90
//Модуль измерения температуры

//Для измерения температуры используется термопара K-типа,
//подключенная ко входу АЦП ADC6.
//Используется внешний источник опорного напряжения типа
//TL431 с напряжением 2.5 В.
//Отсчеты АЦП производятся с интервалом T_SYS, при измерении
//напряжения термопары берется FIR_N отсчетов, которые поступают
//на усредняющий FIR-фильтр с прямоугольным окном.
//Для контроля обрыва термопары используется резистор смещения.
//Если термопара оборвана, АЦП фиксирует максимальное напряжение.
//При этом вместо значения температуры возвращается код обрыва
//термопары TC_BRK.
//Температура холодного спая измеряется дополнительным цифровым
//термометром типа DS18B20.
//Если термометр холодного спая отсутствует, температура
//холодного спая принимается равной TCJ_NOM.
//Когда напряжение термопары и температура холодного спая измерены,
//производится вычисление температуры.
//Температура холодного спая преобразуется в напряжение по линейному
//закону Vcj = Tcj * 40 uV/°C. В диапазоне 0…+50°C погрешность
//не превышает 0.5°C.
//Измеренное напряжение термопары складывается с полученным
//напряжением: Vhj = Vtc + Vcj. В результате получается напряжение
//на горячем спае (т.е. напряжение на термопаре приводится к тому
//значению, которое было бы при нулевой температуре холодного спая).
//Полученное напряжение преобразуется в температуру по таблице
//линеаризации с кусочно-линейной интерполяцией.
//Далее применяется калибровка - умножение температуры на коэффициент
//и прибавление смещения. Калибровка служит для компенсации
//разницы между реальной температурой рабочего тела и температурой
//датчика.

//----------------------------------------------------------------------------

#include "Main.h"
#include "TC.h"
#include "DS18B20.h"

//----------------------------- Константы: -----------------------------------

#define ADC_RES    1023  //разрешение АЦП, квантов
#define ADC_REF    2500  //опорное напряжение АЦП, мВ
#define R_FB      100.0  //номинал резистора обратной связи ОУ, кОм
#define R_GND       1.0  //номинал резистора с инв. входа ОУ на землю, кОм
#define TCJ_K      40.0  //температурный коэффициент для CJ, мкВ/°C
#define TCJ_RES     0.1  //дискретность температуры холодного спая, °C
#define FIR_N (int)(TSAMPLE * 1E3 / T_SYS) //количество точек цифрового фильтра
#define GAIN ((R_FB + R_GND) / R_GND) //коэффициент усиления сигнала термопары

#define TC_V_MAX   24   //максимальное напряжение термопары, мВ
#define TC_POINTS (TC_V_MAX + 1) //количество точек таблицы

//Таблица линеаризации термопары K-типа. В таблице даны значения
//температуры в десятых долях градуса в зависимости от напряжения.
//Диапазон температур 0...+578.7°C. 
//Шаг напряжения - 1 мВ, диапазон 0..+24 мВ:

const int __flash Lin[TC_POINTS] =
{
     0,  250,  495,  736,  976, // 0.. 4 мВ
  1220, 1466, 1715, 1965, 2215, // 5.. 9 мВ
  2462, 2707, 2950, 3190, 3430, //10..14 мВ
  3668, 3906, 4143, 4378, 4614, //15..19 мВ  
  4849, 5083, 5318, 5553, 5787  //20..24 мВ
};

//коды состояний процесса:

enum
{
  TC_STOP,  //процесс остановлен
  TC_START, //фаза запуска процесса
  TC_VTC,   //процесс измерения напряжения термопары
  TC_CALC,  //процесс вычисления температуры
  TC_DONE   //процесс завершен
};

#define TCJN_MIN      0 //минимальная  температура холодного спая, x0.1°C
#define TCJN_NOM    380 //номинальная  температура холодного спая, x0.1°C
#define TCJN_MAX   1000 //максимальная температура холодного спая, x0.1°C

#define SHIFT_MIN -1000 //минимальный  сдвиг температурной шкалы, x0.1°C 
#define SHIFT_NOM     0 //номинальный  сдвиг температурной шкалы, x0.1°C 
#define SHIFT_MAX  1000 //максимальный сдвиг температурной шкалы, x0.1°C

#define GAIN_MIN    250 //минимальный  наклон температурной шкалы, 0.250 
#define GAIN_NOM   1000 //номинальный  наклон температурной шкалы, 1.000 
#define GAIN_MAX   4000 //максимальный наклон температурной шкалы, 4.000

#define ETSIGN   0xBEBE //сигнатура EEPROM

//----------------------------- Переменные: ----------------------------------

static char State;  //состояние модуля измерения температуры
static int Temp;    //текущая температура
static int Tcj;     //текущая температура холодного спая
static int Shift;   //смещение температурной шкалы
static int Gain;    //наклон температурной шкалы

__no_init __eeprom int  ETSign; //сигнатура EEPROM
__no_init __eeprom int  ETcjn;  //Tcjn в EEPROM
__no_init __eeprom int  EShift; //Shift в EEPROM
__no_init __eeprom int  EGain;  //Gain в EEPROM

//-------------------------- Прототипы функций: ------------------------------

int Convert(long code, int tcj); //преобразование кода АЦП в температуру

//----------------- Инициализация измерителя температуры: --------------------

void TC_Init(void)
{
  //Vref = AREF, вход MUX_ADC:
  ADMUX = MUX_ADC;
  //разрешение АЦП, CK/128:
  ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
  DS18B20_Init();            //инициализация модуля термометра DS18B20
  //чтение EEPROM:
  if(ETSign == ETSIGN) //если сигнатура верна, чтение EEPROM
  {
    TC_SetTcjn(ETcjn);
    TC_SetShift(EShift);
    TC_SetGain(EGain);
  }
  else                 //если ошибка сигнатуры, инициализация EEPROM
  {
    TC_SetTcjn(TCJN_NOM);
    TC_SetShift(SHIFT_NOM);
    TC_SetGain(GAIN_NOM);
    ETSign = ETSIGN;
  }
  State = TC_START;          //запуск измерения
}

//------------------------- Процесс измерения: -------------------------------

bool TC_Exe(bool t)
{
  static int SamCnt;                  //счетчик отсчетов АЦП
  static long AdcCode;                //код АЦП при измерении
  bool Update = 0;
  DS18B20_Exe(t);                     //измерение температуры холодного спая
  if(t)
  {
    switch(State)
    {
    //запуск процесса измерения температуры:  
    case TC_START:
      {
        SamCnt = FIR_N;               //загрузка количества отсчетов
        AdcCode = 0;                  //обнуление кода
        ADCSRA |= (1 << ADSC);        //запуск АЦП
        State = TC_VTC;               //процесс измерения
        break;
      }
    //измерение напряжения термопары:  
    case TC_VTC:
      {
        if(SamCnt)
        {
          SamCnt--;                   //счетчик отсчетов
          AdcCode += ADC;             //суммирование кода
          ADCSRA |= (1 << ADSC);      //запуск АЦП
        }
        else
        {
          State = TC_CALC;            //процесс вычисления
        }
        break;
      }
    //вычисление температуры:  
    case TC_CALC:
      {
        int tcj = DS18B20_GetT();     //чтение термометра холодного спая
        if(tcj > T_ERROR)             //если ошибка, Tcj не обновляем
        {
          if(tcj < 0) tcj = 0;        //отсечение отрицательных температур
          Tcj = tcj;                  //обновление Tcj
        }
        Temp = Convert(AdcCode, Tcj); //вычисление температуры
        Update = 1;
        State = TC_START;             //измерение закончено, запуск
        break;
      }
    }
  }
  return(Update);
}

//----------------------- Вычисление температуры: ----------------------------

int Convert(long code, int tcj)
{
  //вычисление напряжения термопары в мкВ:
  int Vtc = (((code * ADC_REF) / ADC_RES) * 1000L) / (long)(FIR_N * GAIN);
  //вычисление эквивалентного напряжения холодного спая:
  //делается приближение, что в диапазоне рабочих температур
  //холодного спая коэффициент термопары постоянен
  //tcj имеет дискретность TCJ_RES
  //TC_K имеет размерность мкВ/°C
  //Vcj представлено в мкВ
  int Vcj = tcj * (int)(TCJ_K * TCJ_RES);
  //вычисление напряжения термопары с компенсацией холодного спая:
  int Vhj = Vtc + Vcj;
  //получение целого числа милливольт:
  signed char Index = Vhj / 1000;
  //проверка выхода за диапазон вниз:
  if(Index < 0) return(0);
  //проверка выхода за диапазон вверх:
  if(Index > TC_POINTS - 2) return(Lin[TC_POINTS - 1] + 1);
  //чтение первой точки таблицы:
  int p1 = Lin[Index];
  //чтение второй точки таблицы:
  int p2 = Lin[++Index];
  //вычисление дельты на интервале 1 мВ:
  int DeltaT = p2 - p1;
  //вычисление дробной части милливольт:
  int DeltaV = Vhj % 1000;
  //линейная интерполяция по отрезку 1 мВ,
  //p1 - температура в десятых градуса:
  p1 = p1 + (long)DeltaV * DeltaT / 1000L;
  //применение калибровки: Нужна ли, нужен ли Shift???
  p1 = (int)((long)p1 * Gain / GAIN_NOM) + Shift;
  return(p1);
}
          
//------------- Установка номинальной температуры холодного спая: ------------

void TC_SetTcjn(int t)
{
  if(t < TCJN_MIN) t = TCJN_MIN;
  if(t > TCJN_MAX) t = TCJN_MAX;
  Tcj = t;
  if(ETcjn != t) ETcjn = t;
}

//--------------- Чтение номинальной температуры холодного спая: -------------

int TC_GetTcjn(void)
{
  return(ETcjn);
}

//------------------ Установка смещения температурной шкалы: -----------------

void TC_SetShift(int s)
{
  if(s < SHIFT_MIN) s = SHIFT_MIN;
  if(s > SHIFT_MAX) s = SHIFT_MAX;
  Shift = s;
  if(EShift != s) EShift = s;
}

//------------------ Чтение смещения температурной шкалы: --------------------

int TC_GetShift(void)
{
  return(Shift);
}

//----------------- Установка наклона температурной шкалы: -------------------

void TC_SetGain(int g)
{
  if(g < GAIN_MIN) g = GAIN_MIN;
  if(g > GAIN_MAX) g = GAIN_MAX;
  Gain = g;
  if(EGain != g) EGain = g;
}

//------------------- Чтение наклона температурной шкалы: --------------------

int TC_GetGain(void)
{
  return(Gain);
}

//-------------------- Чтение температуры холодного спая: --------------------

int TC_GetTcj(void)
{
  return(Tcj);
}

//--------------------------- Чтение температуры: ----------------------------

int TC_GetTemp(void)
{
  return(Temp);
}

//----------------------------------------------------------------------------
